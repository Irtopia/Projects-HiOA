#pragma config(Sensor, S1,     sensCenter,     sensorCOLORFULL)
#pragma config(Sensor, S2,     sensLeft,       sensorCOLORFULL)
#pragma config(Sensor, S3,     distFront,      sensorSONAR)
#pragma config(Sensor, S4,     sensRight,      sensorCOLORFULL)
#pragma config(Motor,  motorA,          dir,           tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          right,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          left,          tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//sensCenter, sensorCOLORFULL kan erstattes med distSide, sensorSONAR ved oenske
//////////////////////////////////////////////////////////////////////////////////////
//
//																LegoCarduino
//																Bilens kode
//
// motor[motorA] = motor[dir] justerer retning
// motor[motorB] = motor[right] justerer fart paa begge bakhjulene
// !!! NB! Husk aa koble bilen til Bluetooth Adafruit EZ-Link !!!
//
//////////////////////////////////////////////////////////////////////////////////////

//definerer overst variablene som brukes i hele programmet
int speedTurn = 100; 			//farten til motoren som justerer retningen
int rotation; 						//maaling av hvor mange grader motoren som justerer
int degTurn = 360/4; 			//grader for motor[dir]
int blckLineColour = 1; 	// = 1 = svart i forhold til RGB sensorene
int redLineColour = 5;		// = 5 = roedt i forhold til sensorene
//int colourCenter;				//hva sensCenter ser, i tilfelle man bruker tre RGB sensorer
int colourRight; 					//hva sensRight ser
int colourLeft; 					//hva sensLeft ser
int speedMtr = 40; 				//standard fart paa bak motorene
int obstacle; 						//avstand sensor foran
//int around; 						//avstand sensor paa side, i tilfelle man bruker to avstandssensorer
int bluetoothmelding = 1;
bool direction[3] = {false, false, false}; 				//bestemmer hvor bilen skal, rett fram som default
bool noProb = true; 			//noProb er true saa langt det IKKE er en kjegle paa veien er det en kjegle er noProb false
bool traffic = false;			//traffic sjekker bluetooth meldinger

//Reset alt til nullverdier for sikkerhets skyld
void resetAll()
{
	nMotorEncoder[dir] = 0; 	//setter rotation lik 0, for sikkerhetsskyld
	motor[dir] = 0;
	nSyncedMotors = synchNone;//no synch (OBLIGATORISK foer synchBC), i tilfeller man vil synkronisere en motor til en annen
	nSyncedMotors = synchBC; 	//synkroniserer motor C til motor B: motor C blir paa en maate slave av motor B, og skal gjoere alt motor B gjoer.
}

//Denne funksjonen leser verdiene, og avgjoer om det er f.eks. hindringer
//funksjonen skriver ogsaa ut paa kjermen viktige info
task readVar()
{
	while (true)
	{
		//Variablene som oppdateres hele tiden...

		rotation = nMotorEncoder[dir];
		//colourCenter = SensorValue[sensCenter];	//I tilfelle man bruker tre RGB sensorer
		colourRight = SensorValue[sensRight];
		colourLeft = SensorValue[sensLeft];
		obstacle = SensorValue[distFront];
		//around = SensorValue[distSide];		//I tilfelle man bruker to avstandssensorer
		bluetoothmelding = message;

		//...blir skrivet ut
		nxtDisplayCenteredTextLine(0, "dist Front: %d", obstacle);
		//nxtDisplayCenteredTextLine(1, "dist Side: %d", around); 	//Det bruker vi til slutt ikke, men kan bli her
		nxtDisplayCenteredTextLine(2, "Lft:%d - Rght:%d", colourLeft, colourRight);
		//nxtDisplayCenteredTextLine(3, "Center:%d", colourCenter);

		//Retningen
		if (colourLeft == blckLineColour)
		{
			nxtDisplayCenteredTextLine(4, "direction: Left");
			direction[0] = true;
			direction[1] = false;
			direction[2] = false;
		}
		if (direction[1] == true)
		{
			nxtDisplayCenteredTextLine(4, "direction: Cntr");
		}
		if (colourRight == blckLineColour)
		{
			nxtDisplayCenteredTextLine(4, "direction: Right");
			direction[0] = false;
			direction[1] = false;
			direction[2] = true;
		}

		//Bluetooth traffic lights
		if (bluetoothmelding == 1 && traffic == true) 	//Groent lys
		{
			nxtDisplayCenteredTextLine(6, "Trfc lght: Green");
		}
		if (bluetoothmelding == 2 && traffic == true)	//Roedt lys
		{
			nxtDisplayCenteredTextLine(6, "Trfc lght: Red");
		}
		if (bluetoothmelding == 3 && traffic == true)	//Gult lys
		{
			nxtDisplayCenteredTextLine(6, "Trfc lght: Yellow");
		}
		if (colourLeft == redLineColour || colourRight == redLineColour)
		{
			traffic = true;
		}
		if (colourLeft != redLineColour && colourRight != redLineColour)
		{
			nxtDisplayCenteredTextLine(6, "not reading BT");
			traffic = false;
		}

		//Avstandsmaaling
		if (obstacle > 25)
		{
			noProb = true;
			nxtDisplayCenteredTextLine(7, "no obstacle");
		}
		if (obstacle <= 25)
		{
			noProb = false;
			nxtDisplayCenteredTextLine(7, "obstacle detected!");
		}
	}
}

task turnRight ()
{
	while (true)
	{
		while (direction[2] == true && rotation < 0.9*degTurn)
		{
			motor[dir] = speedTurn;
		}
		while  (direction[2] == true && rotation >= 0.9*degTurn)
		{
			motor[dir] = 0;
		}
	}
}

task turnLeft ()
{
	while (true)
	{
		while (direction[0] == true && rotation > 0.9*(-degTurn))
		{
			motor[dir] = -speedTurn;
		}
		while (direction[0] == true && rotation <= 0.9*(-degTurn))
		{
			motor[dir] = 0;
		}
	}
}

task steerUp ()
{
	while (true)
	{
			while (direction[1] == true && rotation > 10)
			{
				motor[dir] = -speedTurn*2;
			}
			while (direction[1] == true && rotation < -10)
			{
				motor[dir] = speedTurn*2;
			}
			while (direction[1] == true && rotation <= 10 && rotation >= -10)
			{
				motor[dir] = 0;
			}
	}
}

//BT aktiveres kun nr bilen leser roedt stripe, ellers kjrer bilen som normalt
task drive () //1 = green, 2 = red, 3 = yellow;
{
  while(true)
  {
  	while (noProb == false)
  	{
			motor[right] = 0;
  	}
  	while (traffic == false && noProb == true)
  	{
  		ClearMessage();
  		motor[right] = speedMtr;
  	}
  	while (traffic == true && noProb == true) 		// oppdager roed stripe = er i naerheten av lysskrysset
  	{
   		if(bluetoothmelding == 1) //Green light
    	{
 				motor[right] = speedMtr;
 				wait1Msec(100);
      	ClearMessage();
    	}

    	if(bluetoothmelding == 2)	//Red light
    	{
    		motor[right] = 0;
 				wait1Msec(100);
      	ClearMessage();
     	}

     	if(bluetoothmelding == 3)	//Yellow light
     	{
      	motor[right] = speedMtr/2;
 				wait1Msec(100);
      	ClearMessage();
     	}
    }
  }
}

task main()
{
	nxtDisplayCenteredBigTextLine(2, "HELLO");
	wait1Msec(1000);
	nxtDisplayCenteredBigTextLine(4, "STARTING");
	wait1Msec(1000);
	nxtDisplayClearTextLine(1);
	nxtDisplayClearTextLine(2);
	nxtDisplayClearTextLine(3);
	nxtDisplayClearTextLine(4);
	nxtDisplayClearTextLine(5);
	resetAll();
	StartTask (readVar);
	StartTask (drive);
	StartTask (steerUp);
	StartTask (turnRight);
	StartTask (turnLeft);
	while (true)
	{
		wait1Msec(100);
	}
}
